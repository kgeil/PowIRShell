<#

.Synopsis 
  This script parses windows event logs stored in evtx files and extracts
  events of interest for incident response.

  .Parameter Searchdir
  Secifies the directory containing stored evtx files.

  .Parameter Outputpath
  Specifies path for exported event data. CSV and HTML are supported

  .Parameter FreqServerAddress
  Specifies URL of an instance of Mark Bagget's FreqServer instance.  Defaults to 127.0.0.1.
  FreqServer takes a string, and calculates randomness.  Attackers often create services, scheduled tasks
  and other items with random names. FreqServer is helpful in finding these

  .Parameter FreqServerPort 
  Specifies the port for FreqServer. Defaults to 8080

  .Parameter StartTime
  Specifies date after which to start searching for events. Defaults to 1/1/1601
  Use date format: 1/1/1601

  .Parameter EndTime
  Specifies date before which to start searching for events. Defaults to current date.
  Use date format: 1/1/1601

  .Parameter Csvexport
  Switch that forces all output to csv format in addition to what is output to the console.
  
  .Parameter ArbitraryFileNames
  Switch to be used in cases where log names aren't security.evtx, system.evtx, etc
  This will slow down the script, but if it's a choice between renaming a bunch of files or
  letting the computer do some more work, flip the switch. This happened on a client engagement 
  where I got a bunch of files named "security-pc1.evtx, security-pc2.evtx, etc..."

  .Parameter AuthFailure
  This parses 4625 events and all 4776 events (authentications with explicit credentials)
  NB ** Parsing these auth failures will take significantly longer than not selecting this flag.
  I recommend using the script without this flag set, then after you get results, hit the up arrow once, and
  add the -AuthFailure flag.  That way you can be working while the script does the next step.

  .Example
  C:\Scripts\Win_EVT_Analysis\Get-Artifacts.ps1 -Searchdir C:\ClientFiles\ -OutputPath C:\ClientFiles\ScriptOutput\ -Csvexport

  .Inputs
  Evtx files stored in a directory

  .Outputs
  CSV and HTML files containing evnts of interest from the forensic perspective.

#>
param($Searchdir,$OutputPath,$FreqServerAddress = '127.0.0.1',$FreqServerPort = 8080 ,[DateTime] $StartTime ='1/1/1601', [DateTime] $EndTime = (Get-Date), [switch]$Authfailure, [switch] $Csvexport, [switch] $ArbitraryFileNames)
if ($OutputPath -eq $null ) {Write-Host "No output path specified. Any exported objects will be in $Searchdir" }
if ($OutputPath) {
    if (!(Test-Path $OutputPath)){
        mkdir $OutputPath -Force
        Write-Host "Creating directory: $OutputPath" -ForegroundColor DarkYellow
    }

}    


Function Get-StandardEventInfo($EventToParse){
<#
  .Synopsis: 
  Takes a windows event as a parameter and returns a PSCustomObject: $StandardEventResults, consisting of a timestamp, Windows
  which contains Event ID, and the Machine name of the generating host.

  .Parameter EventToParse
  A windows event, retrieved by the Get-Winevent cmdlet.

  TODO: Try to find the specific error that produces the message: "Get-WinEvent : No events were found that match the specified selection criteria"
  and put it in a try/catch block
#>

    $StandardEventResults = [PSCustomObject]@{
        'Timestamp' = $EventToParse.TimeCreated
        'EventID' = $EventToParse.ID
        'MachineName' = $EventToParse.MachineName.ToString()
    } 
    Return $StandardEventResults
}

Function Get-EventField($EventToParse, $Field){
<#
  .Synopsis: 
  Parses a windows event and returns the event field specified.

  .Parameter EventToParse
  A Windows event generated by the Get-WinEvent cmdlet.

  .Parameter Field
  The desired field from the Windows event XML. 
#>

    #TODO: Find out if it's possible to download the schema and store it somewhere in the script
    $ns = @{e = "http://schemas.microsoft.com/win/2004/08/events/event"}
    $EventToParsexml = [xml]$EventToParse.ToXml()
    $result = Select-Xml -Xml $EventToParsexml -Namespace $ns -XPath "//e:Data[@Name='$field']/text()"|Select-Object -ExpandProperty Node | Select-Object -ExpandProperty Value

    Return $result
}



Function Get-freqScore($StringToTest,$FreqServerAddress = '127.0.0.1',$FreqServerPort = $FreqServerPort){
    <#
      .Synopsis
      Uses Mark Bagget's Freq_server.py. :https://github.com/MarkBaggett/freq
      default is 127.0.0.1:8080
      .Example
      Get-freqScore -stringToTest kevin -serverAddress 127.0.0.1 -port 8080
      TODO: Consider firing up freq.py or freq.exe from this script.  
    #>
    $url = 'http://'+$freqServerAddress+':'+$freqServerPort+'/'+'measure1'+'/'+$stringToTest
    $freqscore = (New-Object Net.webclient).Downloadstring("$url")
    Return $freqscore
}

try{
    $testFreqScore =   Get-freqScore -stringToTest 'teststring' -freqServerAddress $freqServerAddress -freqServerPort $freqserverPort
    Write-Host "trying to contact Freqserver "
    Write-Host "Test score is $testFreqScore"
    start-sleep 1

}
catch{ [System.Management.Automation.MethodInvocationException]
    $testFreqScore = $false
    Write-Host "FreqServer Not found.  Continuing..."
    #TODO: Offer retry/continue with a timer defaulting to continue

}
# Translate Security log events 4720,4721,4722,4723,4724,4725,4726,4738,4781 
# "audit success just wasn't cutting it."

Function Get-SecLogMessageTranslation($wineventID){
    switch ($wineventID){
        4720 {$result = 'A user account was created' }
        4722 {$result = 'A user account was enabled' }
        4723 {$result = 'A user attempted to change his or her own password' }
        4724 {$result = 'An attempt was made to reset an account password' }
        4725 {$result = 'A user account was disabled' }
        4726 {$result = 'A user account was deleted' }
        4738 {$result = 'A user account was changed' }
        4781 {$result = 'The name of an account was changed' }

    }
    return $result
}

Function Get-LogonTypeTranslation($LogonType){
    switch ($LogonType){
        2 {$result = '2: Console Logon' }
        3 {$result = '3: Network Logon: SMB or RDP' }
        4 {$result = '4: Batch Logon (likely scheduled task)' }
        5 {$result = '5: Windows Service Logon' }
        7 {$result = '7: Credentials used to lock or unlock screen, Or RDP session reconnect' }
        8 {$result = '8: Network logon in cleartext' }
        9 {$result = '9: Runas Authentication' }
        10 {$result = '10: Remote interactive (RDP)' }
        11 {$result = '11: Cached Credentials used to log on' }
        12 {$result = '12: Cached Remote Interactive' }
        13 {$result = '13: Cached Unlock' }

    }
    return $result
}

Function Get-NTLMTranslation($NTLMStatus){
    #translations retrieved from: 
    #https://learn.microsoft.com/en-us/windows/security/threat-protection/auditing/event-4776
    $NTLMStatus = [convert]::ToInt32($NTLMStatus, 16)
    switch ($NTLMStatus){
        0xC0000064 {$result = 'Bad Username' }
        0xC000006A {$result = 'Bad Password' }
        0xC000006D {$result = 'Generic Logon Failure' }
        0xC000006F {$result = 'Logon outside of authorized hours' }
        0xC0000070 {$result = 'Unauthorized workstation' }
        0xC0000071 {$result = 'Expired password' }
        0xC0000072 {$result = 'Disabled Account' }
        0xC0000193 {$result = 'Expired Account' }
        0xC0000224 {$result = 'Account logon with Change Password at Next Logon flagged.' }
        0xC0000234 {$result = 'Account locked' }
        0xC0000371 {$result = 'Local account store does not contain secret' }
        0x0 {$result = 'Success' }

    }
    return $result
}

Function Get-Artifacts($Searchdir)
<#
.Synopsis 
  The main function of this script.  Recursively searches through a directory, and 
  extracts events of interest.

  .Parameter Searchdir
  Directory storing evtx files.
#>
{
    if($ArbitraryFileNames){
        $AllEvtxLogs = Get-ChildItem -Path $searchdir -Recurse | Where-Object Name -like "*.evtx"
    }

    if($ArbitraryFileNames){
        $SystemLogs = $AllEvtxLogs
    }
    else {
        $SystemLogs = Get-ChildItem -Path $Searchdir -Recurse | Where-Object Name -eq System.evtx  
    }

    $ServiceCreation = ForEach($log in $SystemLogs ) {
        try {
            Write-Host "Retrieving service creation events from " $log.Fullname -ForegroundColor Green
            Get-WinEvent -FilterHashtable @{path = $log.FullName;ID=7045; StartTime=$StartTime; EndTime=$EndTime} -ErrorAction stop
        }
        catch {
            Write-Host "No service creation events [ID 7045] in " $log.FullName  -ForegroundColor DarkYellow
        }
    }
   #Because we are grabbing logs from multiple machines, we need to sort the array
    $serviceCreation = $serviceCreation | Sort-Object -property TimeCreated 
 
    $ServiceCreationEvents = @()

    ForEach($evt in $ServiceCreation)
    {
        $ServiceCreationEventData = [PSCustomObject]@{
        'Timestamp' =    (Get-StandardEventInfo -EventToParse $evt).Timestamp
        'EventID' = (Get-StandardEventInfo -EventToParse $evt).EventID
        'MachineName' = (Get-StandardEventInfo -EventToParse $evt).MachineName
        'ServiceName' = (Get-EventField -EventToParse $evt -field  ServiceName)
        'ImagePath' = (Get-EventField -EventToParse $evt -field  ImagePath)
        'ServiceAccount' = (Get-EventField -EventToParse $evt -Field ServiceAccount)
        'AccountName' = (Get-EventField -EventToParse $evt -Field AccountName)
        'FreqScore' = if($testFreqScore){
             Get-freqScore -stringToTest $ServiceCreationEventData.ServiceName
              }
              else{'unavailable'}
 
        }
   
        $serviceCreationEvents += $ServiceCreationEventData
   }
   Write-Host "There are " $ServiceCreation.count.ToString() 'Service Creation events' "`n" -ForegroundColor Green   
   Write-Host "they will be exported to CSV in $OutputPath " -ForegroundColor Green
   if($ServiceCreationEvents.count -lt 30){

    $ServiceCreationEvents
    }
   #TODO: Decide if the "unique" part is even necessary
    $uniqueservicecreations = $ServiceCreationEvents | Sort-Object -Unique -Property ImagePath
    if ($csvexport -or $ServiceCreationEvents.count -ge 30){
        Write-Host "Exporting service creation events to CSV " -ForegroundColor Cyan
        $uniqueservicecreations |   Export-Csv -fo -path $OutputPath\UniqueServiceCreationEvents.csv -Encoding UTF8 -NoTypeInformation
        $ServiceCreationEvents | Export-csv -Path $OutputPath\AllServiceCreationEvents.csv -Encoding UTF8 -NoTypeInformation
    }
    #parse security logs
    if($ArbitraryFileNames){
        $SecLogs = $AllEvtxLogs    
    }
    else {
        $SecLogs = Get-ChildItem $SearchDir -Recurse |Where-Object name -eq "Security.evtx"
       
    }
#TODO: Clean up output of this logcleared stuff. It works, but output is balderdash...
    try{
        $logcleared = ForEach($log in $SecLogs) {
            Get-WinEvent -FilterHashtable @{Path = $log.Fullname; ID=1102; StartTime=$StartTime; EndTime=$EndTime} -ErrorAction stop
        }
    }
    catch{
        Write-Host "No evidence that security logs were cleared" -ForegroundColor Green
    }
    if($logcleared){
        $logClearedEvents = @()
        Write-Host "Security log has been cleared!!" -ForegroundColor DarkMagenta
        ForEach($evt in $logcleared){
            $logClearedEventData = [PSCustomObject]@{
                'Timestamp' =    (Get-StandardEventInfo -EventToParse $evt).Timestamp
                'EventID' = (Get-StandardEventInfo -EventToParse $evt).EventID
                'MachineName' = (Get-StandardEventInfo -EventToParse $evt).MachineName
                'TargetUserName'= (Get-EventField -EventToParse $evt -field 'TargetUserName')
                'TargetDomainName' = (Get-EventField -EventToParse $Evt -field 'TargetDomainName')
                'Message' = $evt.message
            }
            $logClearedEvents += $logClearedEventData

        }
        Write-Host  $logClearedEvents -ForegroundColor DarkMagenta
    }
    $AccountEvents=ForEach($log in $SecLogs) {
        Get-WinEvent -FilterHashtable @{
            Path = $log.FullName; ID=4720,4721,4722,4723,4724,4725,4726,4738,4781;
            StartTime=$StartTime; EndTime=$EndTime
        } -ErrorAction SilentlyContinue
    }
    $AccountEvents=$AccountEvents | Sort-Object -Property TimeCreated
    Write-Host "There are " $AccountEvents.count.ToString() 'account management events' "`n" -ForegroundColor Green 
    $AccountManipulationEvents = @()

    ForEach($evt in $AccountEvents){
        $AccountManipulationEventData = [PSCustomObject]@{
            'Timestamp' =    (Get-StandardEventInfo -EventToParse $evt).Timestamp
            'EventID' = (Get-StandardEventInfo -EventToParse $evt).EventID
            'Message' = (Get-SecLogMessageTranslation($evt.ID))
            'MachineName' = (Get-StandardEventInfo -EventToParse $evt).MachineName
            'TargetUserName'= (Get-EventField -EventToParse $evt -field 'TargetUserName')
            'TargetDomainName' = (Get-EventField -EventToParse $Evt -field 'TargetDomainName')
            'AdminActor' =((Get-EventField -EventToParse $evt -field 'SubjectDomainName') + '\' + (Get-EventField -EventToParse $evt -field 'SubjectUserName'))
        }
#TODO: Break these out into separate report sections, ideally with 
#separate sections for " User reset his/her own password", New account created, etc
#TODO: #1 Determine which events can get dropped: I.E. machine account password resets, etc
        $AccountManipulationEvents += $AccountManipulationEventData

    }
    $AccountManipulationEvents |   Export-Csv -path $OutputPath\AccountEvents.csv -Encoding UTF8 -NoTypeInformation
    
    if($AccountEvents.count -le 50 ){
        Write-Host "Account Manipulation events:  "
        $AccountManipulationEvents | ForEach-Object { $_ }
    }
    
$Header = @"
<style>
TABLE {border-width: 1px; border-style: solid; border-color: black; border-collapse: collapse;}
TD {border-width: 1px; padding: 3px; border-style: solid; border-color: black;}
</style>
"@

    forEach ($obj in $AccountManipulationEvents){ 
        $obj | ConvertTo-Html -Property Timestamp,EventID,Message,MachineName,TargetUserName,TargetDomainName,AdminActor -head $Header  | out-file -Append -PSPath "$OutputPath\AccountEvents.html"
    }
#foreach ($i in $arrayofobjects){ $i | ConvertTo-Html -Property Timestamp, EventID, Message | out-file -Append -PSPath C:\ClientFiles\OutputTest\Test.html}
    


    # More security log parsing
    $NewSchTaskEvents = @()

    $NewScheduledTasks = ForEach($log in $SecLogs) {
        Get-WinEvent -FilterHashtable @{
            path = $log.FullName;ID=4698;StartTime=$StartTime; EndTime=$EndTime
        } -ErrorAction SilentlyContinue}
    ForEach($evt in $NewScheduledTasks){
        $NewSchtask = [PSCustomObject]@{
            'Timestamp' =    (Get-StandardEventInfo -EventToParse $evt).Timestamp
            'EventID' = (Get-StandardEventInfo -EventToParse $evt).EventID
            'Message' = 'A scheduled Task was created'
            'MachineName' = (Get-StandardEventInfo -EventToParse $evt).MachineName
            'ScheduledTaskName' = (Get-EventField -EventToParse $Evt -field 'TaskName')
            'AdminActor' = (Get-EventField -EventToParse $evt -field 'SubjectUserName')
            'FreqScore' = if($testFreqScore){
                Get-freqScore -stringToTest $NewSchTask.ScheduledTaskName
                 }
                 else{'unavailable'}
        }
    $NewSchTaskEvents += $NewSchtask

    }

    Write-Host "Scheduled Tasks:  "
    $NewSchTaskEvents | ForEach-Object { $_ } 
    #TODO Output to text
# Failed Authentications
if($Authfailure){
    Write-Host "Setting the AuthenticationFailure switch will add a great deal of time to scropt processing"
    Write-Host "Please be patient.  I suggest getting lunch or coffee. The workstation will beep when script completes" -ForegroundColor DarkGreen
    $FailedAuths = @()

    $FailedAuths = ForEach ($log in $SecLogs) {
        Get-WinEvent -FilterHashtable @{
            path = $log.FullName; ID = 4625; StartTime = $StartTime; EndTime = $EndTime
        } -ErrorAction SilentlyContinue
    }

    Write-Host "There are " $FailedAuths.count.ToString() 'authentication failures' "`n" -ForegroundColor Green   



    $FailedAuthResults = @()

    ForEach ($evt in $FailedAuths) {
        $FailedAuth = [PSCustomObject]@{
            'Timestamp'     = (Get-StandardEventInfo -EventToParse $evt).Timestamp
            'EventID'       = (Get-StandardEventInfo -EventToParse $evt).EventID
            'Message'       = (Get-LogonTypeTranslation(Get-EventField -EventToParse $Evt -Field 'LogonType'))
            'MachineName'   = (Get-StandardEventInfo -EventToParse $evt).MachineName
            'OriginatingIP' = (Get-EventField -EventToParse $Evt -field 'IpAddress')
            'LogonType'     = (Get-EventField -EventToParse $evt -field 'LogonType')
            'SubjectUsername' = (Get-EventField -EventToParse $evt -field 'SubjectUserName')
            'TargetUserName' = (Get-EventField -EventToParse $evt -Field 'TargetUserName')
        }

        $FailedAuthResults += $FailedAuth
    }
    $FailedAuthResults | Export-csv -Path $OutputPath\FailedAuths.csv -Encoding UTF8 -NoTypeInformation


    # $GroupedResults = @{}

    # ForEach ($auth in $FailedAuthResults) {
    #     if ($auth.OriginatingIP -ne $null -and $auth.LogonType -ne $null) {
    #         $LogonType = Get-LogonTypeTranslation -LogonType $auth.LogonType
    #         Write-Host "LogonType: $LogonType"
    #         $key = "$($auth.OriginatingIP) - $LogonType"

    #         if ($GroupedResults.ContainsKey($key)) {
    #             $GroupedResults[$key].Count++
    #         } else {
    #             $GroupedResults[$key] = [PSCustomObject]@{
    #                 'OriginatingIP' = $auth.OriginatingIP
    #                 'LogonType'     = $LogonType
    #                 'Count'         = 1
    #             }
    #         }
    #     }
    # }

    # Write-Host "There are " $GroupedResults.count.ToString() 'Grouped results to export' "`n" -ForegroundColor Green


    # $GroupedResults.Values | Export-csv -Path $OutputPath\FailedAuths.csv -Encoding UTF8 -NoTypeInformation


    #$Report | Export-Csv -Path 'FailedAuthReport.csv' -NoTypeInformation

    #$Report | Export-csv -Path $OutputPath\FailedAuths.csv -Encoding UTF8 -NoTypeInformation

        #NTLM Authentications (event ID 4776)
        Write-Host "Retrieving NTLM auth events.  This may be a while..."

        $NTLMAuths = @()

        $NTLMAuths = ForEach ($log in $SecLogs) {
            Get-WinEvent -FilterHashtable @{
                path = $log.FullName; ID = 4776; StartTime = $StartTime; EndTime = $EndTime
            } -ErrorAction SilentlyContinue
        }

        Write-Host "There are " $NTLMAuths.count.ToString() 'NTLM authentication events' "`n" -ForegroundColor Green   



        $NTLMAuthResults = @()

        ForEach ($evt in $NTLMAuths) {
            $NTLMAuth = [PSCustomObject]@{
                'Timestamp'     = (Get-StandardEventInfo -EventToParse $evt).Timestamp
                'EventID'       = (Get-StandardEventInfo -EventToParse $evt).EventID
                'Message'       = (Get-NTLMTranslation(Get-EventField -EventToParse $evt -Field 'Status'))
                'MachineName'   = (Get-StandardEventInfo -EventToParse $evt).MachineName
                'OriginatingIP' = (Get-EventField -EventToParse $Evt -field 'IpAddress')
                'LogonType'     = (Get-EventField -EventToParse $evt -field 'LogonType')
                'SubjectUsername' = (Get-EventField -EventToParse $evt -field 'SubjectUserName')
                'TargetUserName' = (Get-EventField -EventToParse $evt -Field 'TargetUserName')
                'statuscode' = [string] (Get-EventField -EventToParse $evt -Field 'Status')

            }

            $NTLMAuthResults += $NTLMAuth

        }
        $NTLMAuthResults | Export-Csv -Path $OutputPath\NTLMAuths.csv -Encoding UTF8 -NoTypeInformation

} 
<#
    #TODO: Something with these auth successes.  Lots of things to do, but grabbing them
    all takes up a lot of time.  Parsing auth successes will increase script runtime by
    orders of magnitude...
    $AuthSuccess = ForEach($log in $SecLogs) {
        Get-WinEvent -FilterHashtable @{
            path = $log.FullName;ID=4624;StartTime=$StartTime; EndTime=$EndTime
        } 

    }
#>
    #Windows defender logs
    if($ArbitraryFileNames){
        $DefenderLogs = $AllEvtxLogs
    }
    else{
        $DefenderLogs = Get-ChildItem -Recurse -path $searchdir | Where-Object name -eq "Microsoft-Windows-Windows Defender%4Operational.evtx"
    }
    $DefenderEvents = foreach($log in $DefenderLogs){
        Get-WinEvent -FilterHashtable @{
            path = $log.FullName; ID= 1006,1007,1008,1009,1015,1116,1117,1118,1119,1120;
            StartTime = $StartTime; EndTime = $EndTime
        } -ErrorAction SilentlyContinue
    }
    $DefenderEvents = $DefenderEvents | Sort-Object -Property TimeCreated

    $DefenderEventInfo = @()
    If ($DefenderEvents.count -eq 0){
        Write-Host "No malware detections in Windows defender logs"
    }

    Else{
        foreach($evt in $DefenderEvents){
            $DefenderEventInfo += [PSCustomObject]@{
                'Timestamp' =    (Get-StandardEventInfo -EventToParse $evt).Timestamp
                'EventID' = (Get-StandardEventInfo -EventToParse $evt).EventID
                'Message' = 'A scheduled Task was created'
                'MachineName' = (Get-StandardEventInfo -EventToParse $evt).MachineName
                'DetectionTime' = (Get-EventField -EventToParse $evt -Field 'Detection Time')
                'Threat ID' = (Get-EventField -EventToParse $evt -Field 'Threat ID')
                'Threat Name' = (Get-EventField -EventToParse $evt -Field 'Threat Name')
                'Threat URL' = (Get-EventField -EventToParse $evt -Field 'FWLink')

     
            }

        }

        Write-Host "Defender Events: " $DefenderEventInfo | ForEach-Object { $_ } ##### TODO: Finish with count, and export-csv, etc, or refactor to do this for everything.
    }
#exchangelogs

# $MsExchangeMgmtLogs = Get-ChildItem -Recurse -path $searchdir |Where-Object name -eq "MSExchange Management.evtx"

    #$TermSvcsLogs = Get-ChildItem -Recurse -path $searchdir | Where-Object name -eq "Microsoft-Windows-TerminalServices-RemoteConnectionManager%4Operational.evtx"






    <#

This section commented out because it's the roadmap for future events to parse. I understand
that this is a faux-pas for seasoned coders, but I can't figure out the best place to
put my wish list right now.  I'm sure that git has some kind of functionality to do this,
but it's hard enough learning powershell.  Baby steps...
#TODO: alert on security log event 1102: Event log cleared, and whatever event corresponds
to the system log being cleared
Look into parsing all events listed in my SEC555 OneNote document: https://onedrive.live.com/view.aspx?resid=3A8C84E96890E940%211525&id=documents&wd=target%28Security.one%7CF4702DCB-D2F0-4FD5-A5A3-B486501ACE9E%2FWindows%20events%7C3F750AD2-D287-B64B-97D7-A318EBDB965B%2F%29
onenote:https://d.docs.live.net/3a8c84e96890e940/Documents/ORDA/Security.one#Windows%20events&section-id={F4702DCB-D2F0-4FD5-A5A3-B486501ACE9E}&page-id={3F750AD2-D287-B64B-97D7-A318EBDB965B}&end
TODO:  Grab the first and last event from each log, and write-host: "Events between startdate and enddate"
TODO: "Long-Tail" analysis, whereby counts for every log event are generated, and any event
    ID with less than a count of n are printed to screen, or sent to csv/html/etc...

    $groupChanges = ForEach($log in $SecLogs){
        Get-WinEvent -FilterHashtable @{Path=$log.FullName;ID=4731,4727,4754,4735,4737,4755,4734,4730,
            4758,4732,4728,4756,4733,4729,4757} -ErrorAction SilentlyContinue
        }
    $groupChanges = $groupChanges | Sort-Object -property TimeCreated

    $SchTasks = ForEach($log in $SecLogs) {Get-WinEvent -FilterHashtable @{path = $log.FullName;ID=4698} -ErrorAction SilentlyContinue}
    
    $DefenderLogs = Get-ChildItem -Recurse -path $searchdir | Where name -eq "Microsoft-Windows-Windows Defender%4Operational.evtx"
    #$DefenderEvents = $DefenderEvents|Sort-Object -Property TimeCreated


#>
}

Get-Artifacts -searchdir $searchdir
[Console]::Beep()





